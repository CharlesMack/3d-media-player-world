<!DOCTYPE html>
<html lang="en">
<head>
<!-- Primary Meta Tags -->
<title>3D Media Player World ‚Äî Interactive 3D Concert & Entertainment Universe</title>
<meta name="title" content="3D Media Player World ‚Äî Interactive 3D Concert & Entertainment Universe" />
<meta name="description" content="Step into the 3D Media Player World ‚Äî an interactive web-based concert and media player. Upload your own music, videos, and images to immersive venues with AI crowds, reactive lighting, and pyrotechnics." />
<meta name="keywords" content="3D concert, virtual media player, interactive 3D world, web-based concert, Three.js, immersive entertainment, online concert, music visualizer, AI audience, virtual stage" />
<meta name="author" content="Charles Mack" />
<meta name="robots" content="index, follow" />
<meta name="theme-color" content="#000000" />

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://charlesmack.github.io/3d-media-player-world/" />
<meta property="og:title" content="3D Media Player World ‚Äî Interactive 3D Concert Experience" />
<meta property="og:description" content="Upload music, videos, and images to a fully interactive 3D concert world. Choose venues, control effects, and let the AI audience react to your vibe." />
<meta property="og:site_name" content="3D Media Player World" />
<meta property="og:locale" content="en_US" />

<!-- Twitter -->
<meta property="twitter:card" content="summary" />
<meta property="twitter:url" content="https://charlesmack.github.io/3d-media-player-world/" />
<meta property="twitter:title" content="3D Media Player World ‚Äî Interactive 3D Concert Experience" />
<meta property="twitter:description" content="An immersive 3D concert and media player world. Upload your media, choose venues, control effects, and enjoy dynamic AI audience reactions." />
<meta property="twitter:creator" content="@CharlesMack" />

<!-- GEO SEO -->
<meta name="geo.region" content="US" />
<meta name="geo.placename" content="New York, United States" />
<meta name="geo.position" content="40.7128;-74.0060" />
<meta name="ICBM" content="40.7128, -74.0060" />

<!-- Canonical -->
<link rel="canonical" href="https://charlesmack.github.io/3d-media-player-world/" />

<!-- Optional: Placeholder favicon (will prevent 404 in browser tab) -->
<link rel="icon" href="data:," />

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0015, #1a1040);
            font-family: 'Arial', sans-serif;
            cursor: none;
        }
        canvas { display: block; }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #startMenu {
            pointer-events: auto;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(255, 0, 255, 0.3);
            color: white;
            z-index: 100;
            border: 2px solid rgba(255, 0, 255, 0.5);
        }
        
        #startMenu h1 { 
            font-size: 3em; 
            margin: 0 0 20px; 
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ffff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
        }
        
        #startMenu p { 
            font-size: 1.2em; 
            margin: 0 0 30px; 
            color: #e0e0e0; 
        }
        
        .venue-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .venue-btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #ff006e, #8338ec);
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 25px;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(255, 0, 110, 0.4);
        }
        
        .venue-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 25px rgba(255, 0, 110, 0.6);
        }
        
        #mediaInput { display: none; }
        
        #hud {
            display: none;
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 1.3em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        #controls {
            pointer-events: auto;
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none;
            flex-wrap: wrap;
            justify-content: flex-start;
        }
        
        .control-btn {
            margin: 5px;
            padding: 10px 20px;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 20px;
            font-size: 1em;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
        }
        
        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 20px rgba(0, 255, 255, 0.6);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,0,255,0.8) 50%, transparent 70%);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.7; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
        }

        #vibePanel {
            pointer-events: auto;
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: none;
            min-width: 200px;
        }
        
        .vibe-slider {
            width: 100%;
            margin: 10px 0;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            height: 5px;
            border-radius: 5px;
            outline: none;
        }

        #notifications {
            position: absolute;
            top: 100px;
            right: 20px;
            max-height: 400px;
            overflow-y: auto;
            width: 300px;
            pointer-events: none;
        }
        
        .notification {
            background: linear-gradient(45deg, rgba(255, 0, 255, 0.8), rgba(0, 255, 255, 0.8));
            padding: 12px;
            margin: 8px;
            border-radius: 10px;
            font-size: 1.1em;
            color: white;
            box-shadow: 0 5px 15px rgba(255, 0, 255, 0.4);
            animation: slideIn 0.5s ease-out;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0015, #1a1040);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            color: white;
            font-size: 2em;
            text-align: center;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #ff00ff;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Mobile Controls */
        #mobileControls {
            display: none;
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .joystick-area {
            position: absolute;
            bottom: 20px;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            pointer-events: auto;
            z-index: 10;
        }
        #leftJoystick { left: 20px; }
        #rightJoystick { right: 20px; }

        .joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #mobileButtons {
            position: absolute;
            top: 15%;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }
        
        .mobile-btn {
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ff00ff;
            color: white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
            transition: all 0.2s;
        }
        .mobile-btn:active {
            transform: scale(0.9);
            box-shadow: 0 0 5px rgba(255, 0, 255, 0.8);
        }

        /* Responsive UI adjustments for small screens */
        @media (max-width: 768px) {
            #controls { display: none !important; }
            #vibePanel {
                top: auto;
                bottom: 150px;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
                width: 80%;
                min-width: unset;
                padding: 10px;
            }
            #hud { display: none; }
            #crosshair { display: none; }
            #mobileControls { display: block; }
        }
        .credit-container {
            max-width: 600px;
            margin: 0 auto;
            background-color: #2c2c2c;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .credit-title {
            color: #00ccff;
            font-size: 24px;
            margin-bottom: 10px;
        }
        .credit-text {
            font-size: 16px;
            line-height: 1.5;
        }
        .contact-link {
            color: #00ffcc;
            text-decoration: none;
        }
        .contact-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div>
            <div class="spinner"></div>
            <h2>Loading Concert Experience...</h2>
            <p>Preparing the ultimate venue for you!</p>
        </div>
    </div>

    <div id="ui">
        <div id="startMenu">
            <h1>üéµ WORLD üéµ</h1>
            <p>Your Ultimate Concert & Entertainment Universe</p>
            
<div class="venue-buttons">
    <button class="venue-btn" onclick="startGame('concert')">üé§ Concert Arena</button>
    <button class="venue-btn" onclick="startGame('beach')">üèñÔ∏è Beach Festival</button>
    <button class="venue-btn" onclick="startGame('office')">üè¢ Office Chill</button>
    <button class="venue-btn" onclick="startGame('yacht')">üõ•Ô∏è Luxury Yacht</button>
    <button class="venue-btn" onclick="startGame('mansion')">üè∞ Grand Mansion</button>
    <button class="venue-btn" onclick="startGame('space')">üöÄ Space Station</button>

    <!-- New Download Button -->
    <a href="https://github.com/CharlesMack/3d-media-player-world/archive/refs/heads/main.zip" 
       class="venue-btn" 
       download>
       ‚¨áÔ∏è Download Project
    </a>
</div>

            
          



        </br>

            Creator Credit
        
            This virtual experience, ]3D Media Player World, was created and developed by 
            Charles Mack III. All original 3D environments, interactive elements, and design concepts 
            are the intellectual property of Charles Mack III, unless otherwise noted. This work is licensed under 
            a https://creativecommons.org/licenses/by/4.0/" Creative Commons Attribution 4.0 International License, 
            which requires attribution to the creator when used or shared.
          
            For inquiries, collaborations, or to request permission for use,:
            follow <a href="https://x.com/mackcwm" @mackcwm on X.
            
            Last updated: August 27, 2025
     

        </div>
        
        <div id="hud">
            <div id="venueInfo">üé™ Venue: Concert Arena</div>
            <div id="audienceCount">üë• Audience: 0</div>
            <div id="vibeLevel">‚ö° Vibe: 50%</div>
            <div id="mediaCount">üìÄ Media: 0</div>
        </div>
        
        <div id="controls">
            <button class="control-btn" onclick="spawnVehicle('car')">üöó Spawn Car</button>
            <button class="control-btn" onclick="spawnVehicle('spaceship')">üöÄ Spawn Ship</button>
            <button class="control-btn" onclick="togglePyro()">üéÜ Pyro On/Off</button>
            <button class="control-btn" onclick="changeWeather()">üå¶Ô∏è Weather</button>
            <button class="control-btn" onclick="document.getElementById('mediaInput').click()">üìÅ Add Media</button>
            <button class="control-btn" onclick="toggleConcertControl()">üéõÔ∏è Toggle Concert Control</button>
        </div>
        
        <div id="vibePanel">
            <h3>üéõÔ∏è Concert Control</h3>
            <label>Bass Boost: <input type="range" class="vibe-slider" id="bassBoost" min="0" max="100" value="50"></label>
            <label>Crowd Energy: <input type="range" class="vibe-slider" id="crowdEnergy" min="0" max="100" value="50"></label>
            <label>Light Intensity: <input type="range" class="vibe-slider" id="lightIntensity" min="0" max="100" value="50"></label>
            <label>Pyro Frequency: <input type="range" class="vibe-slider" id="pyroFreq" min="0" max="100" value="30"></label>
        </div>
        
        <div id="notifications"></div>

        <div id="mobileControls">
            <div id="leftJoystick" class="joystick-area">
                <div class="joystick-handle"></div>
            </div>
            <div id="rightJoystick" class="joystick-area">
                <div class="joystick-handle"></div>
            </div>
            <div id="mobileButtons">
                <button class="mobile-btn" onclick="handleObjectInteraction()">üëÜ</button>
                <button class="mobile-btn" onclick="toggleGrabObject()">‚úã</button>
                <button class="mobile-btn" onclick="handleObjectDeletion()">üóëÔ∏è</button>
                <button class="mobile-btn" onclick="document.getElementById('mediaInput').click()">üìÅ</button>
                <button class="mobile-btn" onclick="toggleConcertControl()">üéõÔ∏è</button>
            </div>
        </div>
    </div>
    
    <div id="crosshair"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Enhanced game state with concert features
        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();
        let listener, audioLoader, audioContext;
        let gameState = 'menu';
        let currentVenue = 'concert';
        
        // Enhanced collections
        let mediaObjects = [], audienceBots = [], vehicles = [], spaceships = [];
        let concertLights = [], pyroSystems = [], particles = [];
        let stages = [], concertEffects = [];
        
        // Enhanced controls
        let keys = {}, mouse = { x: 0, y: 0, sensitivity: 0.002 };
        let moveSpeed = 20, flySpeed = 30;
        let controlsEnabled = false;

        // Mobile controls
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let leftJoystick = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, handle: null };
        let rightJoystick = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, handle: null };
        
        // Concert-specific variables
        let vibeLevel = 50, crowdEnergy = 50, bassBoost = 50;
        let pyroEnabled = true, weatherMode = 'clear';
        let audioAnalysers = [], globalBeatDetection = null;
        
        // Object manipulation
        const raycaster = new THREE.Raycaster();
        let selectedObject = null, grabbedObject = null;
        let grabDistance = 5;

        // Vehicle physics
        let playerVehicle = null;
        let vehicleSpeed = 0, maxSpeed = 50;
        
        // Lighting and effects
        let spotlights = [], laserLights = [], smokeMachines = [];
        let concertStage = null, crowdArea = null;

        // Initialize the experience
        function init() {
            // Hide loading screen after a moment
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
            }, 2000);

            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            // Enhanced audio setup
            listener = new THREE.AudioListener();
            camera.add(listener);
            audioLoader = new THREE.AudioLoader();
            audioContext = listener.context;
            
            // Global beat detection
            globalBeatDetection = {
                analyser: null,
                beatThreshold: 0.3,
                lastBeat: 0
            };

            // Event listeners
            setupEventListeners();
            
            // Start with menu
            camera.position.set(0, 5, 10);

            // Hide/show PC/mobile controls
            if (isMobile) {
                document.getElementById('controls').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('mobileControls').style.display = 'block';
            } else {
                document.getElementById('mobileControls').style.display = 'none';
            }
        }

        function setupEventListeners() {
            if (isMobile) {
                setupMobileControls();
            } else {
                // Keyboard
                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
                
                // Mouse
                document.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mouseup', onMouseUp);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('wheel', onMouseWheel);
                
                // Pointer lock
                document.addEventListener('pointerlockchange', () => {
                    controlsEnabled = document.pointerLockElement === document.body;
                });
            }
            
            // Shared events
            window.addEventListener('resize', onWindowResize);
            document.getElementById('mediaInput').addEventListener('change', handleMediaUpload);
            document.getElementById('bassBoost').addEventListener('input', updateVibeSettings);
            document.getElementById('crowdEnergy').addEventListener('input', updateVibeSettings);
            document.getElementById('lightIntensity').addEventListener('input', updateVibeSettings);
            document.getElementById('pyroFreq').addEventListener('input', updateVibeSettings);
        }

        function setupMobileControls() {
            const leftJoystickArea = document.getElementById('leftJoystick');
            const rightJoystickArea = document.getElementById('rightJoystick');
            leftJoystick.handle = leftJoystickArea.querySelector('.joystick-handle');
            rightJoystick.handle = rightJoystickArea.querySelector('.joystick-handle');

            let touchLookActive = false;
            let lastTouchX, lastTouchY;

            document.addEventListener('touchstart', (event) => {
                for (let i = 0; i < event.touches.length; i++) {
                    const touch = event.touches[i];
                    
                    // Left joystick for movement
                    if (leftJoystickArea.contains(touch.target)) {
                        leftJoystick.active = true;
                        leftJoystick.startX = touch.clientX;
                        leftJoystick.startY = touch.clientY;
                        leftJoystick.currentX = touch.clientX;
                        leftJoystick.currentY = touch.clientY;
                        break;
                    }
                    
                    // Right joystick for camera
                    if (rightJoystickArea.contains(touch.target)) {
                        rightJoystick.active = true;
                        rightJoystick.startX = touch.clientX;
                        rightJoystick.startY = touch.clientY;
                        rightJoystick.currentX = touch.clientX;
                        rightJoystick.currentY = touch.clientY;
                        break;
                    }

                    // Look gesture
                    if (touch.target.tagName === 'CANVAS') {
                        touchLookActive = true;
                        lastTouchX = touch.clientX;
                        lastTouchY = touch.clientY;
                    }
                }
            }, false);

            document.addEventListener('touchmove', (event) => {
                event.preventDefault(); // Prevent scrolling/zooming

                for (let i = 0; i < event.touches.length; i++) {
                    const touch = event.touches[i];

                    if (leftJoystick.active) {
                        leftJoystick.currentX = touch.clientX;
                        leftJoystick.currentY = touch.clientY;
                    }

                    if (rightJoystick.active) {
                        rightJoystick.currentX = touch.clientX;
                        rightJoystick.currentY = touch.clientY;
                    }
                }

                // Camera rotation with a single touch outside of joysticks
                if (touchLookActive) {
                    const deltaX = touch.clientX - lastTouchX;
                    const deltaY = touch.clientY - lastTouchY;

                    camera.rotation.y -= deltaX * mouse.sensitivity * 5; // Increased sensitivity for mobile
                    camera.rotation.x -= deltaY * mouse.sensitivity * 5;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                    
                    lastTouchX = touch.clientX;
                    lastTouchY = touch.clientY;
                }
            }, false);

            document.addEventListener('touchend', (event) => {
                leftJoystick.active = false;
                rightJoystick.active = false;
                touchLookActive = false;
                leftJoystick.handle.style.transform = 'translate(-50%, -50%)';
                rightJoystick.handle.style.transform = 'translate(-50%, -50%)';
            }, false);
            
            // Interactivity for touch
            document.addEventListener('click', (event) => {
                if (event.target.tagName === 'CANVAS') {
                    // Raycast on click for object interaction
                    const rect = renderer.domElement.getBoundingClientRect();
                    const x = (event.clientX - rect.left) / rect.width;
                    const y = (event.clientY - rect.top) / rect.height;
                    const coords = new THREE.Vector2(x * 2 - 1, -y * 2 + 1);

                    raycaster.setFromCamera(coords, camera);
                    const intersects = raycaster.intersectObjects([...mediaObjects, ...vehicles, ...spaceships]);
                    
                    if (intersects.length > 0) {
                        handleObjectClick(intersects[0].object);
                    }
                }
            }, false);
        }

        function startGame(venue) {
            currentVenue = venue;
            gameState = 'playing';
            
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('controls').style.display = isMobile ? 'none' : 'block';
            document.getElementById('vibePanel').style.display = 'block';
            document.getElementById('crosshair').style.display = isMobile ? 'none' : 'block';

            if (!isMobile) {
                document.body.requestPointerLock();
            }
            
            const venueNames = {
                concert: 'üé§ Concert Arena',
                beach: 'üèñÔ∏è Beach Festival',
                office: 'üè¢ Office Space',
                yacht: 'üõ•Ô∏è Luxury Yacht',
                mansion: 'üè∞ Grand Mansion',
                space: 'üöÄ Space Station'
            };
            document.getElementById('venueInfo').textContent = `üé™ Venue: ${venueNames[venue]}`;
            
            setupVenue(venue);
            spawnAudienceBots(20);
            setupConcertLighting();
            setupPyrotechnics();
            
            animate();
            
            addNotification(`üéâ Welcome to ${venueNames[venue]}!`);
            addNotification("üéµ Upload your media to start the concert!");
        }

        function setupVenue(venue) {
            scene.clear();
            scene.add(camera);
            camera.add(listener);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            switch(venue) {
                case 'concert': setupConcertVenue(); break;
                case 'beach': setupBeachVenue(); break;
                case 'office': setupOfficeVenue(); break;
                case 'yacht': setupYachtVenue(); break;
                case 'mansion': setupMansionVenue(); break;
                case 'space': setupSpaceVenue(); break;
            }
        }

        function setupConcertVenue() {
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundTexture = createCheckerboardTexture();
            const groundMaterial = new THREE.MeshLambertMaterial({ map: groundTexture, color: 0x222222 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            const stageGeometry = new THREE.BoxGeometry(30, 2, 20);
            const stageMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.2 });
            concertStage = new THREE.Mesh(stageGeometry, stageMaterial);
            concertStage.position.set(0, 1, -30);
            concertStage.castShadow = true;
            scene.add(concertStage);
            
            for(let i = 0; i < 5; i++) {
                const seatGeometry = new THREE.BoxGeometry(60, 2, 8);
                const seatMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const seat = new THREE.Mesh(seatGeometry, seatMaterial);
                seat.position.set(0, i * 3 + 2, 20 + i * 10);
                seat.castShadow = true;
                scene.add(seat);
            }
            
            scene.fog = new THREE.FogExp2(0x000033, 0.005);
            
            camera.position.set(0, 15, 40);
        }

        function setupBeachVenue() {
            const groundGeometry = new THREE.PlaneGeometry(300, 300);
            const sandTexture = createSandTexture();
            const groundMaterial = new THREE.MeshLambertMaterial({ map: sandTexture });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            
            const waterGeometry = new THREE.PlaneGeometry(300, 100);
            const waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.8,
                roughness: 0.1,
                metalness: 0.1
            });
            const water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.z = -100;
            scene.add(water);
            
            const stageGeometry = new THREE.CylinderGeometry(15, 15, 2, 16);
            const stageMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
            concertStage = new THREE.Mesh(stageGeometry, stageMaterial);
            concertStage.position.set(0, 1, 0);
            scene.add(concertStage);
            
            for(let i = 0; i < 10; i++) {
                createPalmTree(
                    Math.random() * 200 - 100,
                    Math.random() * 200 - 100
                );
            }
            
            scene.fog = new THREE.Fog(0x87CEEB, 50, 300);
            camera.position.set(0, 10, 30);
        }

        function setupSpaceVenue() {
            createStarfield();
            
            const platformGeometry = new THREE.CylinderGeometry(50, 50, 5, 16);
            const platformMaterial = new THREE.MeshStandardMaterial({
                color: 0x333366,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x002244,
                emissiveIntensity: 0.3
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = -2;
            scene.add(platform);
            
            const stageGeometry = new THREE.CylinderGeometry(15, 15, 3, 8);
            const stageMaterial = new THREE.MeshStandardMaterial({
                color: 0x666699,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x004488,
                emissiveIntensity: 0.5
            });
            concertStage = new THREE.Mesh(stageGeometry, stageMaterial);
            concertStage.position.y = 2;
            scene.add(concertStage);
            
            for(let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const deckGeometry = new THREE.BoxGeometry(12, 2, 8);
                const deckMaterial = new THREE.MeshStandardMaterial({
                    color: 0x444477,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const deck = new THREE.Mesh(deckGeometry, deckMaterial);
                deck.position.set(
                    Math.cos(angle) * 35,
                    5 + Math.sin(i) * 3,
                    Math.sin(angle) * 35
                );
                scene.add(deck);
            }
            
            camera.position.set(0, 20, 40);
            
            scene.fog = null;
        }

        function setupOfficeVenue() {
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            
            for(let x = -40; x <= 40; x += 20) {
                for(let z = -40; z <= 40; z += 20) {
                    if(Math.abs(x) < 10 && Math.abs(z) < 10) continue;
                    
                    const deskGeometry = new THREE.BoxGeometry(8, 1, 4);
                    const deskMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const desk = new THREE.Mesh(deskGeometry, deskMaterial);
                    desk.position.set(x, 1, z);
                    scene.add(desk);
                }
            }
            
            const presentationGeometry = new THREE.BoxGeometry(20, 0.5, 15);
            const presentationMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            concertStage = new THREE.Mesh(presentationGeometry, presentationMaterial);
            concertStage.position.set(0, 0.5, 0);
            scene.add(concertStage);
            
            camera.position.set(0, 8, 25);
        }

        function setupYachtVenue() {
            const oceanGeometry = new THREE.PlaneGeometry(500, 500);
            const oceanMaterial = new THREE.MeshStandardMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.9
            });
            const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
            ocean.rotation.x = -Math.PI / 2;
            ocean.position.y = -5;
            scene.add(ocean);
            
            const hullGeometry = new THREE.BoxGeometry(60, 8, 15);
            const hullMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.position.y = 2;
            scene.add(hull);
            
            const deckGeometry = new THREE.BoxGeometry(55, 2, 12);
            const deckMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            concertStage = new THREE.Mesh(deckGeometry, deckMaterial);
            concertStage.position.y = 6;
            scene.add(concertStage);
            
            const superGeometry = new THREE.BoxGeometry(20, 12, 10);
            const superMaterial = new THREE.MeshStandardMaterial({ color: 0xF5F5F5 });
            const superstructure = new THREE.Mesh(superGeometry, superMaterial);
            superstructure.position.set(15, 10, 0);
            scene.add(superstructure);
            
            scene.fog = new THREE.Fog(0x87CEEB, 100, 400);
            camera.position.set(-20, 15, 25);
        }

        function setupMansionVenue() {
            const floorGeometry = new THREE.PlaneGeometry(80, 80);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0xF8F8FF,
                metalness: 0.1,
                roughness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            
            const wallHeight = 15;
            const walls = [
                { pos: [0, wallHeight/2, -40], size: [80, wallHeight, 2] },
                { pos: [0, wallHeight/2, 40], size: [80, wallHeight, 2] },
                { pos: [-40, wallHeight/2, 0], size: [2, wallHeight, 80] },
                { pos: [40, wallHeight/2, 0], size: [2, wallHeight, 80] }
            ];
            
            walls.forEach(wall => {
                const wallGeometry = new THREE.BoxGeometry(...wall.size);
                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                wallMesh.position.set(...wall.pos);
                scene.add(wallMesh);
            });
            
            const chandelierGeometry = new THREE.CylinderGeometry(12, 12, 1, 16);
            const chandelierMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                metalness: 0.8,
                roughness: 0.1
            });
            concertStage = new THREE.Mesh(chandelierGeometry, chandelierMaterial);
            concertStage.position.y = 1;
            scene.add(concertStage);
            
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const columnGeometry = new THREE.CylinderGeometry(2, 2, 15, 8);
                const columnMaterial = new THREE.MeshStandardMaterial({ color: 0xF5F5DC });
                const column = new THREE.Mesh(columnGeometry, columnMaterial);
                column.position.set(
                    Math.cos(angle) * 25,
                    7.5,
                    Math.sin(angle) * 25
                );
                scene.add(column);
            }
            
            camera.position.set(0, 12, 35);
        }

        function spawnAudienceBots(count) {
            audienceBots = [];
            
            for(let i = 0; i < count; i++) {
                const botGroup = new THREE.Group();
                
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 8);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6)
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.6;
                botGroup.add(body);
                
                const headGeometry = new THREE.SphereGeometry(0.25, 8, 6);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.5, 0.7)
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.5;
                botGroup.add(head);
                
                const bot = botGroup;
                
                let x, z;
                if(currentVenue === 'concert') {
                    x = Math.random() * 80 - 40;
                    z = Math.random() * 30 + 10;
                } else if(currentVenue === 'beach') {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 20 + Math.random() * 30;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                } else if(currentVenue === 'space') {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 25 + Math.random() * 15;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                } else {
                    x = Math.random() * 60 - 30;
                    z = Math.random() * 60 - 30;
                }
                
                bot.position.set(x, 2, z);
                bot.castShadow = true;
                
                bot.userData = {
                    type: 'audience',
                    energy: Math.random(),
                    danceStyle: Math.floor(Math.random() * 4),
                    originalY: bot.position.y,
                    bouncePhase: Math.random() * Math.PI * 2,
                    bodyMaterial: bodyMaterial,
                    headMaterial: headMaterial,
                    originalBodyColor: bodyMaterial.color.clone(),
                    originalHeadColor: headMaterial.color.clone()
                };
                
                scene.add(bot);
                audienceBots.push(bot);
            }
            
            updateAudienceCount();
        }

        function setupConcertLighting() {
            const spotlight = new THREE.SpotLight(0xffffff, 2, 100, Math.PI / 6, 0.5);
            spotlight.position.set(0, 30, -20);
            spotlight.target.position.set(0, 0, -30);
            spotlight.castShadow = true;
            spotlight.shadow.camera.near = 10;
            spotlight.shadow.camera.far = 100;
            scene.add(spotlight);
            scene.add(spotlight.target);
            concertLights.push(spotlight);

            const colors = [0xff0040, 0x40ff00, 0x0040ff, 0xff8000, 0x8000ff, 0x00ff80];
            
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const light = new THREE.SpotLight(colors[i % colors.length], 1.5, 80, Math.PI / 4, 0.3);
                light.position.set(
                    Math.cos(angle) * 25,
                    20,
                    Math.sin(angle) * 25 - 15
                );
                
                const target = new THREE.Object3D();
                target.position.set(0, 0, -30);
                scene.add(target);
                light.target = target;
                
                light.userData = {
                    originalPosition: light.position.clone(),
                    targetOriginal: target.position.clone(),
                    moveRadius: 15,
                    moveSpeed: 0.5 + Math.random() * 0.5,
                    colorPhase: Math.random() * Math.PI * 2
                };
                
                scene.add(light);
                concertLights.push(light);
            }

            for(let i = 0; i < 12; i++) {
                const laser = new THREE.DirectionalLight(0xff00ff, 0.8);
                laser.position.set(
                    Math.random() * 40 - 20,
                    15 + Math.random() * 10,
                    -35 + Math.random() * 10
                );
                
                laser.userData = {
                    type: 'laser',
                    sweepSpeed: 1 + Math.random() * 2,
                    sweepRadius: 20 + Math.random() * 15,
                    phase: Math.random() * Math.PI * 2
                };
                
                scene.add(laser);
                laserLights.push(laser);
            }
        }

        function setupPyrotechnics() {
            const pyroPoints = [];
            for(let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                pyroPoints.push({
                    x: Math.cos(angle) * 20,
                    y: 1,
                    z: Math.sin(angle) * 20 - 30
                });
            }
            
            pyroSystems = pyroPoints;
        }

        function handleMediaUpload(event) {
            const files = event.target.files;
            for(let file of files) {
                processMediaFile(file);
            }
        }

        function processMediaFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const mediaData = e.target.result;
                let mediaObject;
                
                if(file.type.startsWith('image/')) {
                    mediaObject = createImageMedia(mediaData, file);
                } else if(file.type.startsWith('video/')) {
                    mediaObject = createVideoMedia(mediaData, file);
                } else if(file.type.startsWith('audio/')) {
                    mediaObject = createAudioMedia(mediaData, file);
                }
                
                if(mediaObject) {
                    const stagePos = concertStage ? concertStage.position : new THREE.Vector3(0, 2, -30);
                    mediaObject.position.set(
                        stagePos.x + (Math.random() - 0.5) * 20,
                        stagePos.y + 2 + Math.random() * 5,
                        stagePos.z + (Math.random() - 0.5) * 15
                    );
                    
                    scene.add(mediaObject);
                    mediaObjects.push(mediaObject);
                    updateMediaCount();
                    
                    addNotification(`üéµ Added ${file.name} to the show!`);
                    
                    if(pyroEnabled) {
                        triggerPyroEffect(mediaObject.position);
                    }
                }
            };
            reader.readAsDataURL(file);
        }

        function createImageMedia(dataUrl, file) {
            const texture = new THREE.TextureLoader().load(dataUrl);
            const geometry = new THREE.PlaneGeometry(4, 3);
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData = {
                type: 'image',
                fileName: file.name,
                originalScale: mesh.scale.clone(),
                glowIntensity: 0
            };
            
            return mesh;
        }

        function createVideoMedia(dataUrl, file) {
            const video = document.createElement('video');
            video.src = dataUrl;
            video.loop = true;
            video.muted = false;
            video.crossOrigin = 'anonymous';
            
            const texture = new THREE.VideoTexture(video);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            const geometry = new THREE.PlaneGeometry(6, 4);
            const material = new THREE.MeshStandardMaterial({
                map: texture,
                side: THREE.DoubleSide
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData = {
                type: 'video',
                video: video,
                fileName: file.name,
                originalScale: mesh.scale.clone(),
                glowIntensity: 0,
                muted: false
            };
            
            video.play().catch(() => {
                addNotification(`Click ${file.name} to start video!`);
            });
            
            return mesh;
        }

        function createAudioMedia(dataUrl, file) {
            const audio = new THREE.PositionalAudio(listener);
            const analyser = new THREE.AudioAnalyser(audio, 256);
            
            audioLoader.load(dataUrl, (buffer) => {
                audio.setBuffer(buffer);
                audio.setLoop(true);
                audio.setRefDistance(5);
                audio.setVolume(0.8);
                
                if(!globalBeatDetection.analyser) {
                    globalBeatDetection.analyser = analyser;
                }
            });
            
            const geometry = new THREE.IcosahedronGeometry(2, 1);
            const material = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x003366,
                emissiveIntensity: 0.5
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.add(audio);
            
            mesh.userData = {
                type: 'audio',
                audio: audio,
                analyser: analyser,
                fileName: file.name,
                originalScale: mesh.scale.clone(),
                originalColor: material.color.clone(),
                beatHistory: [],
                isPlaying: false,
                muted: false
            };
            
            audioAnalysers.push(analyser);
            return mesh;
        }

        function spawnVehicle(type) {
            if(type === 'car') {
                spawnCar();
            } else if(type === 'spaceship') {
                spawnSpaceship();
            }
        }

        function spawnCar() {
            const bodyGeometry = new THREE.BoxGeometry(4, 1.5, 2);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xff4444,
                metalness: 0.8,
                roughness: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(camera.position.x + 5, 1, camera.position.z);
            body.castShadow = true;
            
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 8);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            
            const wheelPositions = [
                [-1.5, -0.5, 0.8], [1.5, -0.5, 0.8],
                [-1.5, -0.5, -0.8], [1.5, -0.5, -0.8]
            ];
            
            const wheels = [];
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(...pos);
                wheel.rotation.z = Math.PI / 2;
                body.add(wheel);
                wheels.push(wheel);
            });
            
            const underglowColors = [0xff0000, 0x00ff00, 0x0000ff, 0xff00ff];
            underglowColors.forEach((color, i) => {
                const light = new THREE.PointLight(color, 2, 10);
                light.position.set((i % 2) * 2 - 1, -0.8, (Math.floor(i / 2)) * 2 - 1);
                body.add(light);
            });
            
            body.userData = {
                type: 'vehicle',
                subtype: 'car',
                speed: 0,
                maxSpeed: 500,
                acceleration: 10,
                wheels: wheels,
                engineSound: null
            };
            
            scene.add(body);
            vehicles.push(body);
            playerVehicle = body;
            
            addNotification('üöó Sports car spawned! Use WASD to drive!');
        }

        function spawnSpaceship() {
            const hullGeometry = new THREE.ConeGeometry(2, 6, 8);
            const hullMaterial = new THREE.MeshStandardMaterial({
                color: 0x4444ff,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0x001144,
                emissiveIntensity: 0.3
            });
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.position.set(camera.position.x, camera.position.y + 10, camera.position.z);
            hull.rotation.x = Math.PI;
            
            const engineGeometry = new THREE.SphereGeometry(0.8, 8, 6);
            const engineMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            const engine = new THREE.Mesh(engineGeometry, engineMaterial);
            engine.position.y = 2.5;
            hull.add(engine);
            
            const thrusterGeometry = new THREE.BufferGeometry();
            const thrusterCount = 50;
            const thrusterPositions = new Float32Array(thrusterCount * 3);
            
            for(let i = 0; i < thrusterCount; i++) {
                thrusterPositions[i * 3] = (Math.random() - 0.5) * 0.5;
                thrusterPositions[i * 3 + 1] = 2.5 + Math.random() * 3;
                thrusterPositions[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
            }
            
            thrusterGeometry.setAttribute('position', new THREE.BufferAttribute(thrusterPositions, 3));
            const thrusterMaterial = new THREE.PointsMaterial({
                color: 0x00ffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            const thrusters = new THREE.Points(thrusterGeometry, thrusterMaterial);
            hull.add(thrusters);
            
            hull.userData = {
                type: 'vehicle',
                subtype: 'spaceship',
                speed: 0,
                maxSpeed: 40,
                acceleration: 0.8,
                hover: true,
                thrusters: thrusters,
                engine: engine
            };
            
            scene.add(hull);
            spaceships.push(hull);
            playerVehicle = hull;
            
            addNotification('üöÄ Spaceship spawned! Use WASD + F/C to fly!');
        }

        function updateVibeSettings() {
            bassBoost = document.getElementById('bassBoost').value;
            crowdEnergy = document.getElementById('crowdEnergy').value;
            const lightIntensity = document.getElementById('lightIntensity').value / 100;
            const pyroFreq = document.getElementById('pyroFreq').value;
            
            concertLights.forEach(light => {
                light.intensity = light.userData?.originalIntensity || 1.5;
                light.intensity *= lightIntensity;
            });
            
            vibeLevel = (parseInt(bassBoost) + parseInt(crowdEnergy)) / 2;
            document.getElementById('vibeLevel').textContent = `‚ö° Vibe: ${Math.round(vibeLevel)}%`;
        }

        function updateAudienceCount() {
            document.getElementById('audienceCount').textContent = `üë• Audience: ${audienceBots.length}`;
        }

        function updateMediaCount() {
            document.getElementById('mediaCount').textContent = `üìÄ Media: ${mediaObjects.length}`;
        }

        function togglePyro() {
            pyroEnabled = !pyroEnabled;
            addNotification(pyroEnabled ? 'üéÜ Pyrotechnics ON!' : 'üéÜ Pyrotechnics OFF!');
        }

        function toggleConcertControl() {
            const panel = document.getElementById('vibePanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
            addNotification(panel.style.display === 'block' ? 'üéõÔ∏è Concert Control Shown!' : 'üéõÔ∏è Concert Control Hidden!');
        }

        function changeWeather() {
            const weathers = ['clear', 'foggy', 'stormy', 'party'];
            const currentIndex = weathers.indexOf(weatherMode);
            weatherMode = weathers[(currentIndex + 1) % weathers.length];
            
            switch(weatherMode) {
                case 'clear':
                    if(scene.fog) scene.fog.density = 0.005;
                    break;
                case 'foggy':
                    scene.fog = new THREE.FogExp2(0x666666, 0.02);
                    break;
                case 'stormy':
                    scene.fog = new THREE.FogExp2(0x333366, 0.03);
                    break;
                case 'party':
                    scene.fog = new THREE.FogExp2(0xff00ff, 0.01);
                    break;
            }
            
            addNotification(`üå¶Ô∏è Weather: ${weatherMode.toUpperCase()}!`);
        }

        function triggerPyroEffect(position) {
            if(!pyroEnabled) return;
            
            const particleCount = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for(let i = 0; i < particleCount; i++) {
                positions[i * 3] = position.x + (Math.random() - 0.5) * 2;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z + (Math.random() - 0.5) * 2;
                
                velocities[i * 3] = (Math.random() - 0.5) * 10;
                velocities[i * 3 + 1] = Math.random() * 15 + 5;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 10;
                
                const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 1
            });
            
            const pyro = new THREE.Points(geometry, material);
            scene.add(pyro);
            
            particles.push({
                system: pyro,
                time: 0,
                lifetime: 3,
                type: 'pyro'
            });
        }

        function detectBeat() {
            if(!globalBeatDetection.analyser) return false;
            
            const data = globalBeatDetection.analyser.getFrequencyData();
            const bassRange = data.slice(0, 10);
            const bassLevel = bassRange.reduce((sum, val) => sum + val, 0) / bassRange.length / 255;
            
            const now = performance.now();
            if(bassLevel > globalBeatDetection.beatThreshold && 
               now - globalBeatDetection.lastBeat > 300) {
                globalBeatDetection.lastBeat = now;
                return true;
            }
            return false;
        }

        function updateAudioVisuals() {
            mediaObjects.forEach(obj => {
                if(obj.userData.type === 'audio' && obj.userData.analyser) {
                    const data = obj.userData.analyser.getFrequencyData();
                    const avgFreq = data.reduce((sum, val) => sum + val, 0) / data.length / 255;
                    
                    const scale = 1 + avgFreq * (bassBoost / 100);
                    obj.scale.setScalar(scale);
                    
                    const hue = (avgFreq * 360 + performance.now() * 0.1) % 360;
                    obj.material.color.setHSL(hue / 360, 0.8, 0.5);
                    
                    obj.material.emissiveIntensity = 0.2 + avgFreq * 0.8;
                }
            });
            
            if(detectBeat()) {
                concertLights.forEach(light => {
                    light.intensity *= 2;
                    setTimeout(() => light.intensity /= 2, 100);
                });
                
                if(pyroEnabled && Math.random() < document.getElementById('pyroFreq').value / 100) {
                    const randomPyro = pyroSystems[Math.floor(Math.random() * pyroSystems.length)];
                    if(randomPyro) {
                        triggerPyroEffect(new THREE.Vector3(randomPyro.x, randomPyro.y, randomPyro.z));
                    }
                }
                
                audienceBots.forEach(bot => {
                    bot.userData.bouncePhase = Math.random() * Math.PI * 2;
                    bot.userData.bodyMaterial.color.setHSL(Math.random(), 0.8, 0.6);
                });
            }
        }

        function updateConcertLighting() {
            const time = performance.now() * 0.001;
            
            concertLights.forEach((light, index) => {
                if(light.userData && light.userData.originalPosition) {
                    const moveX = Math.sin(time * light.userData.moveSpeed + index) * light.userData.moveRadius;
                    const moveZ = Math.cos(time * light.userData.moveSpeed + index) * light.userData.moveRadius;
                    
                    light.position.x = light.userData.originalPosition.x + moveX;
                    light.position.z = light.userData.originalPosition.z + moveZ;
                    
                    const hue = (time * 50 + light.userData.colorPhase * 180 / Math.PI) % 360;
                    light.color.setHSL(hue / 360, 1, 0.5);
                    
                    if(light.target && light.target !== concertStage && light.userData.targetOriginal) {
                        const targetX = Math.sin(time * 0.7 + index * 0.5) * 10;
                        const targetZ = Math.cos(time * 0.7 + index * 0.5) * 10 - 30;
                        light.target.position.set(targetX, 0, targetZ);
                    }
                }
            });
            
            laserLights.forEach((laser, index) => {
                if(laser.userData) {
                    const phase = time * laser.userData.sweepSpeed + laser.userData.phase;
                    const x = Math.sin(phase) * laser.userData.sweepRadius;
                    const z = Math.cos(phase) * laser.userData.sweepRadius;
                    
                    laser.position.x += (x - laser.position.x) * 0.1;
                    laser.position.z += (z - laser.position.z) * 0.1;
                    
                    const hue = (phase * 30) % 360;
                    laser.color.setHSL(hue / 360, 1, 0.5);
                }
            });
        }

        function updateAudienceBots() {
            const time = performance.now() * 0.001;
            
            audienceBots.forEach((bot, index) => {
                const bounce = Math.sin(time * 4 + bot.userData.bouncePhase) * 0.3;
                const sway = Math.sin(time * 2 + index * 0.1) * 0.2;
                
                bot.position.y = bot.userData.originalY + Math.abs(bounce);
                bot.rotation.y = sway;
                bot.rotation.z = sway * 0.5;
                
                const energyMultiplier = (crowdEnergy / 100) * bot.userData.energy;
                bot.position.y += Math.abs(bounce) * energyMultiplier;
                
                if(Math.random() < 0.01) {
                    bot.material.color.setHSL(Math.random(), 0.8, 0.6);
                    setTimeout(() => {
                        bot.material.color.copy(bot.userData.color);
                    }, 200);
                }
                
                if(Math.random() < 0.005) {
                    const stageDir = concertStage ? concertStage.position : new THREE.Vector3(0, 0, -30);
                    bot.lookAt(stageDir);
                }
            });
        }

        function updateParticles() {
            const delta = clock.getDelta();
            
            particles = particles.filter(p => {
                p.time += delta;
                
                if(p.time > p.lifetime) {
                    scene.remove(p.system);
                    return false;
                }
                
                const positions = p.system.geometry.attributes.position.array;
                const velocities = p.system.geometry.attributes.velocity.array;
                
                for(let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3] += velocities[i * 3] * delta;
                    positions[i * 3 + 1] += velocities[i * 3 + 1] * delta;
                    positions[i * 3 + 2] += velocities[i * 3 + 2] * delta;
                    
                    if(p.type === 'pyro') {
                        velocities[i * 3 + 1] -= 9.8 * delta;
                    }
                }
                
                p.system.geometry.attributes.position.needsUpdate = true;
                
                p.system.material.opacity = 1 - (p.time / p.lifetime);
                
                return true;
            });
        }

        function updateVehicles() {
            vehicles.forEach(vehicle => {
                if(vehicle.userData.wheels) {
                    vehicle.userData.wheels.forEach(wheel => {
                        wheel.rotation.x += vehicle.userData.speed * 0.1;
                    });
                }
            });
            
            spaceships.forEach(ship => {
                const hover = Math.sin(performance.now() * 0.002) * 2;
                ship.position.y += hover * 0.01;
                
                if(ship.userData.thrusters) {
                    const positions = ship.userData.thrusters.geometry.attributes.position.array;
                    for(let i = 0; i < positions.length / 3; i++) {
                        positions[i * 3 + 1] += (Math.random() - 0.5) * 0.1;
                    }
                    ship.userData.thrusters.geometry.attributes.position.needsUpdate = true;
                }
            });
        }

        // Input handling
        function onKeyDown(event) {
            keys[event.code] = true;
            
            switch(event.code) {
                case 'KeyE':
                    handleObjectInteraction();
                    break;
                case 'KeyT':
                    handleObjectDeletion();
                    break;
                case 'Space':
                    if(playerVehicle) {
                        addNotification(playerVehicle.userData.subtype === 'car' ? 'üöó BEEP BEEP!' : 'üöÄ BOOST!');
                    }
                    break;
                case 'KeyG':
                    toggleGrabObject();
                    break;
                case 'KeyP':
                    toggleAllMedia();
                    break;
                case 'KeyM':
                    toggleMuteObject();
                    break;
                case 'KeyU':
                case 'KeyN':
                    document.getElementById('mediaInput').click();
                    break;
                case 'KeyV':
                    toggleConcertControl();
                    break;
                case 'KeyQ':
                    if (playerVehicle) {
                        addNotification(`Exited ${playerVehicle.userData.subtype}!`);
                        playerVehicle = null;
                        document.body.requestPointerLock();
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function onMouseDown(event) {
            if(!controlsEnabled) return;
            
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects([...mediaObjects, ...audienceBots, ...vehicles, ...spaceships]);
            
            if(intersects.length > 0) {
                const target = intersects[0].object;
                handleObjectClick(target);
            }
            document.body.requestPointerLock();
        }

        function onMouseUp(event) {}

        function onMouseMove(event) {
            if(!controlsEnabled) return;
            
            camera.rotation.y -= event.movementX * mouse.sensitivity;
            camera.rotation.x -= event.movementY * mouse.sensitivity;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }

        function onMouseWheel(event) {
            if(grabbedObject) {
                const scale = grabbedObject.scale.x + event.deltaY * -0.01;
                grabbedObject.scale.setScalar(Math.max(0.1, Math.min(5, scale)));
            } else if(selectedObject) {
                grabDistance = Math.max(2, Math.min(20, grabDistance + event.deltaY * 0.01));
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function handleObjectInteraction() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects([...mediaObjects, ...vehicles, ...spaceships]);
            
            if(intersects.length > 0) {
                const target = intersects[0].object;
                handleObjectClick(target);
            }
            if (!isMobile) {
                document.body.requestPointerLock();
            }
        }

        function handleObjectClick(target) {
            if(target.userData.type === 'audio') {
                if(target.userData.audio.isPlaying) {
                    target.userData.audio.stop();
                    target.userData.isPlaying = false;
                    addNotification(`‚è∏Ô∏è Paused: ${target.userData.fileName}`);
                } else {
                    target.userData.audio.play();
                    target.userData.isPlaying = true;
                    addNotification(`‚ñ∂Ô∏è Playing: ${target.userData.fileName}`);
                }
            } else if(target.userData.type === 'video') {
                if(target.userData.video.paused) {
                    target.userData.video.play();
                    addNotification(`‚ñ∂Ô∏è Playing: ${target.userData.fileName}`);
                } else {
                    target.userData.video.pause();
                    addNotification(`‚è∏Ô∏è Paused: ${target.userData.fileName}`);
                }
            } else if(target.userData.type === 'vehicle') {
                playerVehicle = target;
                addNotification(`üöó Entered ${target.userData.subtype}!`);
            }
            if (!isMobile) {
                document.body.requestPointerLock();
            }
        }

        function toggleMuteObject() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects([...mediaObjects]);
            
            if(intersects.length > 0) {
                const target = intersects[0].object;
                if(target.userData.type === 'audio') {
                    target.userData.muted = !target.userData.muted;
                    target.userData.audio.setVolume(target.userData.muted ? 0 : 0.8);
                    addNotification(target.userData.muted ? `üîá Muted: ${target.userData.fileName}` : `üîä Unmuted: ${target.userData.fileName}`);
                } else if(target.userData.type === 'video') {
                    target.userData.muted = !target.userData.muted;
                    target.userData.video.muted = target.userData.muted;
                    addNotification(target.userData.muted ? `üîá Muted: ${target.userData.fileName}` : `üîä Unmuted: ${target.userData.fileName}`);
                }
            }
        }

        function handleObjectDeletion() {
            if(grabbedObject) {
                if(grabbedObject.userData.audio) {
                    grabbedObject.userData.audio.stop();
                }
                if(grabbedObject.userData.video) {
                    grabbedObject.userData.video.pause();
                }
                
                scene.remove(grabbedObject);
                mediaObjects = mediaObjects.filter(obj => obj !== grabbedObject);
                vehicles = vehicles.filter(obj => obj !== grabbedObject);
                spaceships = spaceships.filter(obj => obj !== grabbedObject);
                
                addNotification(`üóëÔ∏è Deleted: ${grabbedObject.userData.fileName || 'object'}`);
                grabbedObject = null;
                updateMediaCount();
                if (!isMobile) {
                    document.body.requestPointerLock();
                }
            }
        }

        function toggleGrabObject() {
            if(grabbedObject) {
                grabbedObject.material.emissive.set(0x000000);
                grabbedObject = null;
                addNotification('üëã Released object');
            } else {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects([...mediaObjects, ...vehicles, ...spaceships]);
                
                if(intersects.length > 0) {
                    grabbedObject = intersects[0].object;
                    grabbedObject.material.emissive.set(0xff4444);
                    grabDistance = intersects[0].distance;
                    addNotification(`‚úã Grabbed: ${grabbedObject.userData.fileName || 'object'}`);
                }
            }
            if (!isMobile) {
                document.body.requestPointerLock();
            }
        }

        function toggleAllMedia() {
            let playingCount = 0;
            let pausedCount = 0;
            
            mediaObjects.forEach(obj => {
                if(obj.userData.type === 'audio') {
                    if(obj.userData.isPlaying) {
                        obj.userData.audio.stop();
                        obj.userData.isPlaying = false;
                        pausedCount++;
                    } else {
                        obj.userData.audio.play();
                        obj.userData.isPlaying = true;
                        playingCount++;
                    }
                } else if(obj.userData.type === 'video') {
                    if(!obj.userData.video.paused) {
                        obj.userData.video.pause();
                        pausedCount++;
                    } else {
                        obj.userData.video.play();
                        playingCount++;
                    }
                }
            });
            
            if(playingCount > 0) {
                addNotification(`‚ñ∂Ô∏è Started ${playingCount} media items`);
            } else if(pausedCount > 0) {
                addNotification(`‚è∏Ô∏è Paused ${pausedCount} media items`);
            }
            if (!isMobile) {
                document.body.requestPointerLock();
            }
        }

        function updateMovement() {
            const delta = clock.getDelta();
            
            if(playerVehicle) {
                updateVehicleMovement(delta);
            } else {
                updatePlayerMovement(delta);
            }
            
            if(grabbedObject) {
                const direction = new THREE.Vector3(0, 0, -grabDistance);
                direction.applyQuaternion(camera.quaternion);
                grabbedObject.position.copy(camera.position).add(direction);
            }
        }

        function updatePlayerMovement(delta) {
            const moveVector = new THREE.Vector3();
            const speed = keys.ShiftLeft ? flySpeed : moveSpeed;
            
            if (isMobile) {
                const joystickMagnitude = Math.sqrt(
                    (leftJoystick.currentX - leftJoystick.startX) ** 2 +
                    (leftJoystick.currentY - leftJoystick.startY) ** 2
                );
                const joystickRadius = 75;
                
                if (joystickMagnitude > 10) {
                    const normalizedX = (leftJoystick.currentX - leftJoystick.startX) / joystickRadius;
                    const normalizedY = (leftJoystick.currentY - leftJoystick.startY) / joystickRadius;
                    
                    moveVector.z = -normalizedY;
                    moveVector.x = -normalizedX;

                    const handleX = normalizedX * joystickRadius;
                    const handleY = normalizedY * joystickRadius;
                    leftJoystick.handle.style.transform = `translate(${handleX - 30}px, ${handleY - 30}px)`;
                } else {
                    leftJoystick.handle.style.transform = 'translate(-50%, -50%)';
                }
                
                const rightJoystickMagnitude = Math.sqrt(
                    (rightJoystick.currentX - rightJoystick.startX) ** 2 +
                    (rightJoystick.currentY - rightJoystick.startY) ** 2
                );
                
                if (rightJoystickMagnitude > 10) {
                    const normalizedX = (rightJoystick.currentX - rightJoystick.startX) / joystickRadius;
                    const normalizedY = (rightJoystick.currentY - rightJoystick.startY) / joystickRadius;
                    
                    camera.rotation.y -= normalizedX * 0.05;
                    camera.rotation.x -= normalizedY * 0.05;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                    const handleX = normalizedX * joystickRadius;
                    const handleY = normalizedY * joystickRadius;
                    rightJoystick.handle.style.transform = `translate(${handleX - 30}px, ${handleY - 30}px)`;
                } else {
                    rightJoystick.handle.style.transform = 'translate(-50%, -50%)';
                }

            } else { // PC controls
                if(keys.KeyW) moveVector.z -= 1;
                if(keys.KeyS) moveVector.z += 1;
                if(keys.KeyA) moveVector.x -= 1;
                if(keys.KeyD) moveVector.x += 1;
                if(keys.KeyF || keys.Space) moveVector.y += 1;
                if(keys.KeyC) moveVector.y -= 1;
            }
            
            if(moveVector.length() > 0) {
                moveVector.normalize();
                moveVector.multiplyScalar(speed * delta);
                
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                const up = new THREE.Vector3(0, 1, 0);
                
                camera.position.add(forward.multiplyScalar(moveVector.z));
                camera.position.add(right.multiplyScalar(moveVector.x));
                camera.position.add(up.multiplyScalar(moveVector.y));
            }
        }

        function updateVehicleMovement(delta) {
            if(!playerVehicle) return;
            
            const vehicle = playerVehicle;
            let acceleration = 0;
            let steering = 0;

            if (isMobile) {
                const joystickMagnitude = Math.sqrt(
                    (leftJoystick.currentX - leftJoystick.startX) ** 2 +
                    (leftJoystick.currentY - leftJoystick.startY) ** 2
                );
                const joystickRadius = 75;

                if (joystickMagnitude > 10) {
                    const normalizedY = (leftJoystick.currentY - leftJoystick.startY) / joystickRadius;
                    const normalizedX = (leftJoystick.currentX - leftJoystick.startX) / joystickRadius;
                    acceleration = -normalizedY * vehicle.userData.acceleration;
                    steering = -normalizedX;
                }
            } else { // PC controls
                if(keys.KeyW) acceleration = vehicle.userData.acceleration;
                if(keys.KeyS) acceleration = -vehicle.userData.acceleration * 0.5;
                if(keys.KeyA) steering = -1;
                if(keys.KeyD) steering = 1;
            }
            
            vehicle.userData.speed += acceleration * delta;
            vehicle.userData.speed *= 0.95;
            vehicle.userData.speed = Math.max(-vehicle.userData.maxSpeed * 0.5, 
                                            Math.min(vehicle.userData.maxSpeed, vehicle.userData.speed));
            
            if(Math.abs(vehicle.userData.speed) > 0.1) {
                const moveDistance = vehicle.userData.speed * delta;
                const direction = new THREE.Vector3(0, 0, -moveDistance);
                direction.applyQuaternion(vehicle.quaternion);
                vehicle.position.add(direction);
                
                if(vehicle.userData.subtype === 'car') {
                    vehicle.rotation.y += steering * (vehicle.userData.speed / vehicle.userData.maxSpeed) * delta * 2;
                } else if(vehicle.userData.subtype === 'spaceship') {
                    if(keys.KeyF || keys.Space) vehicle.position.y += 10 * delta;
                    if(keys.KeyC) vehicle.position.y -= 10 * delta;
                    vehicle.rotation.y += steering * delta;
                    vehicle.rotation.x += (keys.KeyW ? -0.3 : keys.KeyS ? 0.3 : 0) * delta;
                }
            }
            
            const vehiclePos = vehicle.position.clone();
            const offset = new THREE.Vector3(0, 5, 8);
            offset.applyQuaternion(vehicle.quaternion);
            
            camera.position.lerp(vehiclePos.add(offset), delta * 3);
            camera.lookAt(vehicle.position);
        }

        function addNotification(message) {
            const notifications = document.getElementById('notifications');
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            
            notifications.appendChild(notification);
            
            setTimeout(() => {
                if(notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 4000);
            
            while(notifications.children.length > 5) {
                notifications.removeChild(notifications.firstChild);
            }
        }

        function createCheckerboardTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 128;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#333333';
            context.fillRect(0, 0, 128, 128);
            
            context.fillStyle = '#555555';
            for(let x = 0; x < 8; x++) {
                for(let y = 0; y < 8; y++) {
                    if((x + y) % 2) {
                        context.fillRect(x * 16, y * 16, 16, 16);
                    }
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);
            return texture;
        }

        function createSandTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 256;
            const context = canvas.getContext('2d');
            
            const gradient = context.createLinearGradient(0, 0, 256, 256);
            gradient.addColorStop(0, '#F4E4BC');
            gradient.addColorStop(1, '#DEB887');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 256, 256);
            
            for(let i = 0; i < 1000; i++) {
                context.fillStyle = `rgba(${139 + Math.random() * 20}, ${69 + Math.random() * 20}, ${19 + Math.random() * 20}, 0.3)`;
                context.fillRect(Math.random() * 256, Math.random() * 256, 2, 2);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(5, 5);
            return texture;
        }

        function createPalmTree(x, z) {
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 8, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 4, z);
            scene.add(trunk);
            
            for(let i = 0; i < 6; i++) {
                const leafGeometry = new THREE.ConeGeometry(0.2, 4, 4);
                const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                
                const angle = (i / 6) * Math.PI * 2;
                leaf.position.set(
                    x + Math.cos(angle) * 2,
                    8,
                    z + Math.sin(angle) * 2
                );
                leaf.rotation.z = angle + Math.PI / 2;
                leaf.rotation.x = Math.PI / 6;
                scene.add(leaf);
            }
        }

        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1000;
            const positions = new Float32Array(starCount * 3);
            
            for(let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 2000;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 2,
                transparent: true,
                opacity: 0.8
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function animate() {
            if(gameState !== 'playing') return;
            
            requestAnimationFrame(animate);
            
            updateMovement();
            updateAudioVisuals();
            updateConcertLighting();
            updateAudienceBots();
            updateParticles();
            updateVehicles();
            
            renderer.render(scene, camera);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
